import { loadSchema } from "./type-gen/fetch-schema";
import { generateInterface } from "./type-gen/mapper";
import { toPascalCase } from "./type-gen/utils";
import fs from "fs/promises";
import path from "path";
import prettier from "prettier";
import { exec } from "child_process";
import util from "util";

const execAsync = util.promisify(exec);

const OUT_DIR = path.resolve(process.cwd(), "src/types/generated");
const OUT_FILE = path.join(OUT_DIR, "storyblok.d.ts");

async function validateGeneratedFile() {
  console.log("ğŸ›¡ï¸  Verifying generated types with TSC...");
  try {
    // Run TSC specifically on the generated file to check for syntax validity
    // We utilize the project's tsconfig to ensure environment compatibility
    await execAsync(`npx tsc --noEmit --skipLibCheck "${OUT_FILE}"`);
    console.log("âœ… Type verification passed.");
  } catch (error: any) {
    console.error("âŒ Type verification failed!");
    console.error(error.stdout || error.stderr);
    // If validation fails, we should delete the potentially corrupt file
    // or exit with error code to stop CI
    process.exit(1); 
  }
}

async function fileExists(path: string) {
    try {
        await fs.access(path);
        return true;
    } catch {
        return false;
    }
}

async function main() {
  console.log("ğŸš€ Starting Type Generation Pipeline...");

  const { components, hasChanged } = await loadSchema();

  if (!hasChanged && await fileExists(OUT_FILE)) {
     console.log("âœ… Schema unchanged & type file exists. Skipping generation.");
     return;
  }

  console.log("ğŸ› ï¸  Schema changed or missing types. Generating...");

  const interfaces = components.map(generateInterface).join("\n\n");

  const componentNames = components.map((c: any) => toPascalCase(c.name) + 'Blok');
  
  // Safety: Handle empty schema case
  const unionType = componentNames.length > 0 
    ? `export type StoryblokComponent = ${componentNames.join(" | ")};`
    : `export type StoryblokComponent = never;`;

  const fileContent = `/**
 * ğŸ¤– AUTO-GENERATED FILE. DO NOT EDIT.
 * Generated by scripts/generate-types.ts
 * * Source: Storyblok Management API
 * Timestamp: ${new Date().toISOString()}
 */
import type { StoryblokAsset, StoryblokLink, StoryblokRichText } from '@/types/storyblok';

${interfaces}

/**
 * Discriminated Union of all Storyblok Components.
 * Use this to type-check 'blok.component' in loops.
 */
${unionType}
`;

  const prettierConfig = await prettier.resolveConfig(process.cwd()) || {};
  const formatted = await prettier.format(fileContent, { 
    ...prettierConfig, 
    parser: "typescript" 
  });

  await fs.mkdir(OUT_DIR, { recursive: true });
  await fs.writeFile(OUT_FILE, formatted);
  
  // New Step: Verification
  await validateGeneratedFile();
  
  console.log(`âœ¨ Strictly typed definitions generated at: src/types/generated/storyblok.d.ts`);
}

main().catch((err) => {
  console.error("âŒ Fatal Error in Type Generator:", err);
  process.exit(1);
});
