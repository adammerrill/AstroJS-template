/**
 * @fileoverview Type, Schema, and Mock Generation Pipeline for Storyblok Components
 *
 * @module generate-types
 * @version 1.2.1
 * @author Atom Merrill
 * @license MIT
 *
 * @description
 * This script orchestrates the complete type generation pipeline for Storyblok components:
 * 1. Fetches and caches component schemas from Storyblok Management API
 * 2. Generates TypeScript interface definitions (.d.ts)
 * 3. Generates Zod validation schemas for runtime type checking
 * 4. Generates mock factory functions for testing
 * 5. Formats all output with Prettier for consistency
 *
 * The pipeline is designed for CI/CD integration and development workflows,
 * providing type safety across the entire Astro/Svelte application stack.
 *
 * @changelog
 * - v1.2.1: Fixed Zod schema imports to include all component types
 * - v1.2.0: Fixed type conflicts by using shared types module
 */

import { loadSchema } from "./type-gen/fetch-schema";
import { generateInterface } from "./type-gen/mapper";
import { generateZodSchema } from "./type-gen/zod-mapper";
import { generateMockFactory } from "./type-gen/mock-mapper";
import { toPascalCase } from "./type-gen/utils";
import type { ComponentSchema } from "./type-gen/types";
import fs from "fs/promises";
import path from "path";
import prettier from "prettier";

// --- Configuration Constants ---

const OUT_DIR_TYPES = path.resolve(process.cwd(), "src/types/generated");
const OUT_DIR_LIB = path.resolve(process.cwd(), "src/lib");
const TYPES_FILE = path.join(OUT_DIR_TYPES, "storyblok.d.ts");
const SCHEMAS_FILE = path.join(OUT_DIR_TYPES, "schemas.ts");
const MOCKS_FILE = path.join(OUT_DIR_LIB, "mocks.generated.ts");

// --- Main Pipeline Function ---

async function main(): Promise<void> {
  console.log("üöÄ Starting Type, Schema & Mock Generation Pipeline...");

  // Stage 1: Load component schemas from Storyblok
  const { components } = await loadSchema();

  console.log("üõ†Ô∏è  Generating artifacts...");

  // --- Stage 2: Generate TypeScript Interface Definitions ---

  const interfaces = components
    .map((component: ComponentSchema) => generateInterface(component))
    .join("\n\n");

  const componentNames = components.map(
    (component: ComponentSchema) => toPascalCase(component.name) + "Blok",
  );

  const unionType =
    componentNames.length > 0
      ? `export type StoryblokComponent = ${componentNames.join(" | ")};`
      : `export type StoryblokComponent = never;`;

  const typesContent = `/**
 * ü§ñ AUTO-GENERATED FILE. DO NOT EDIT.
 * Source: Storyblok Management API
 * Generated: (Timestamp removed to prevent CI drift)
 *
 * @description
 * This file contains TypeScript type definitions for all Storyblok components.
 * These types ensure type safety when working with Storyblok content in your
 * Astro components and Svelte 5 components.
 *
 * @warning
 * This file is automatically generated by scripts/generate-types.ts
 * Any manual changes will be overwritten on the next generation run.
 *
 * To modify types, update the Storyblok component schemas in the Storyblok
 * interface and re-run: pnpm run generate:types
 */

import type { StoryblokAsset, StoryblokLink } from '@/types/storyblok';

${interfaces}

${unionType}
`;

  // --- Stage 3: Generate Zod Validation Schemas ---

  const zodSchemas = components
    .map((component: ComponentSchema) => generateZodSchema(component))
    .join("\n");

  const schemaNames = components.map(
    (component: ComponentSchema) => toPascalCase(component.name) + "BlokSchema",
  );

  // CRITICAL FIX: Only import types that are actually used in z.ZodType<T> annotations
  // This prevents "unused import" errors

  // Find which components have circular references (use z.ZodType<T> annotation)
  const componentsWithCircularRefs = components.filter(
    (component: ComponentSchema) =>
      Object.values(component.schema).some((field) => field.type === "bloks"),
  );

  const typesUsedInAnnotations = componentsWithCircularRefs.map(
    (component: ComponentSchema) => toPascalCase(component.name) + "Blok",
  );

  // Always import StoryblokComponent for the union schema
  const allTypesToImport = [
    ...new Set([...typesUsedInAnnotations, "StoryblokComponent"]),
  ];

  const componentTypeImports =
    allTypesToImport.length > 0
      ? `import type {\n  ${allTypesToImport.join(",\n  ")}\n} from './storyblok';`
      : `import type { StoryblokComponent } from './storyblok';`;

  const zodUnion =
    schemaNames.length > 0
      ? `export const StoryblokComponentSchema: z.ZodType<StoryblokComponent> = z.union([
  ${schemaNames.join(",\n  ")}
]);`
      : `export const StoryblokComponentSchema: z.ZodType<never> = z.never();`;

  const schemasContent = `/**
 * ü§ñ AUTO-GENERATED ZOD SCHEMAS. DO NOT EDIT.
 * Generated: (Timestamp removed to prevent CI drift)
 * 
 * @description
 * This file contains Zod validation schemas for all Storyblok components.
 * Use these schemas to validate component data at runtime, especially when:
 * - Receiving data from the Storyblok API
 * - Processing user input that maps to Storyblok structures
 * - Ensuring data integrity in complex workflows
 *
 * @warning
 * This file is automatically generated by scripts/generate-types.ts
 * Any manual changes will be overwritten on the next generation run.
 *
 * @see {@link https://zod.dev/} Zod Documentation
 */

import { z } from 'zod';
${componentTypeImports}

${zodSchemas}

${zodUnion}
`;

  // --- Stage 4: Generate Mock Factory Functions ---

  const mockFunctions = components
    .map((component: ComponentSchema) => generateMockFactory(component))
    .join("\n");

  const mocksContent = `/**
 * ü§ñ AUTO-GENERATED MOCK FACTORY. DO NOT EDIT.
 * Generated: (Timestamp removed to prevent CI drift)
 *
 * @description
 * This file contains mock factory functions for all Storyblok components.
 * Use these factories in your tests to generate realistic test data:
 *
 * @example
 * import { MockFactory } from '@/lib/mocks.generated';
 *
 * // Generate a mock hero component
 * const mockHero = MockFactory.createHeroBlok();
 *
 * // Use in Vitest/Jest tests
 * describe('HeroComponent', () => {
 *   it('renders correctly', () => {
 *     const props = MockFactory.createHeroBlok();
 *     // ... test logic
 *   });
 * });
 *
 * @warning
 * This file is automatically generated by scripts/generate-types.ts
 * Any manual changes will be overwritten on the next generation run.
 *
 * @see {@link https://fakerjs.dev/} Faker.js Documentation
 */

import { faker } from '@faker-js/faker';
import type * as Types from '../types/generated/storyblok';

export const MockFactory = {
${mockFunctions}
};
`;

  // --- Stage 5: Format with Prettier ---

  console.log("‚ú® Formatting generated files with Prettier...");

  const prettierConfig = (await prettier.resolveConfig(process.cwd())) || {};

  const formattedTypes = await prettier.format(typesContent, {
    ...prettierConfig,
    parser: "typescript",
  });

  const formattedSchemas = await prettier.format(schemasContent, {
    ...prettierConfig,
    parser: "typescript",
  });

  const formattedMocks = await prettier.format(mocksContent, {
    ...prettierConfig,
    parser: "typescript",
  });

  // --- Stage 6: Write Output Files ---

  console.log("üìù Writing generated files...");

  await fs.mkdir(OUT_DIR_TYPES, { recursive: true });
  await fs.mkdir(OUT_DIR_LIB, { recursive: true });

  await fs.writeFile(TYPES_FILE, formattedTypes);
  console.log(`‚úÖ Types generated: ${TYPES_FILE}`);

  await fs.writeFile(SCHEMAS_FILE, formattedSchemas);
  console.log(`‚úÖ Schemas generated: ${SCHEMAS_FILE}`);

  await fs.writeFile(MOCKS_FILE, formattedMocks);
  console.log(`‚úÖ Mocks generated: ${MOCKS_FILE}`);

  console.log("\nüéâ Generation pipeline complete!");
  console.log(
    "üí° Run 'pnpm check' to validate the generated types across the project.",
  );
}

// --- Error Handling & Execution ---

main().catch((err: unknown) => {
  console.error("‚ùå Fatal Error:", err);
  process.exit(1);
});
